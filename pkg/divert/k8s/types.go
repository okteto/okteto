// Copyright 2025 The Okteto Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package k8s

import (
	"context"

	apixclient "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

type Logger interface {
	Infof(format string, args ...interface{})
}

// CRDInstallationChecker is a struct to check if the Divert CRD is installed in the cluster
type CRDInstallationChecker struct {
	Client apixclient.Interface
	Logger Logger
}

// Divert represents a configuration to route traffic from a service in the shared namespace
// to a service with the same name in the namespace where this resource is created, based on
// the Okteto divert HTTP header value defined in this resource
type Divert struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata"`

	Spec DivertSpec `json:"spec"`
}

// DivertList represents the resource when a list of divert items is requested
type DivertList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Divert `json:"items"`
}

// DivertSpec represents the spec of a divert resource
type DivertSpec struct {
	// SharedNamespace is the namespace where the original service is deployed,
	// from which traffic will be routed to the diverted namespace based on the divert key
	SharedNamespace string `json:"sharedNamespace"`
	// Service whose traffic will be routed from the shared namespace to the diverted one based on the divert key
	Service string `json:"service"`
	// DivertKey is the value to be set in the Okteto divert HTTP header when traffic to the target service
	// should be routed from the shared namespace to the diverted one
	DivertKey string `json:"divertKey"`
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Divert) DeepCopyInto(out *Divert) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Divert.
func (in *Divert) DeepCopy() *Divert {
	if in == nil {
		return nil
	}
	out := new(Divert)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Divert) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DivertList) DeepCopyInto(out *DivertList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Divert, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DivertList.
func (in *DivertList) DeepCopy() *DivertList {
	if in == nil {
		return nil
	}
	out := new(DivertList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DivertList) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DivertSpec) DeepCopyInto(out *DivertSpec) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DivertSpec.
func (in *DivertSpec) DeepCopy() *DivertSpec {
	if in == nil {
		return nil
	}
	out := new(DivertSpec)
	in.DeepCopyInto(out)
	return out
}

// IsInstalled checks if the Divert CRD is installed in the cluster
func (c *CRDInstallationChecker) IsInstalled(ctx context.Context) (bool, error) {
	_, err := c.Client.ApiextensionsV1().CustomResourceDefinitions().Get(ctx, CRDName, metav1.GetOptions{})
	if apierrors.IsNotFound(err) {
		return false, nil
	}
	if err != nil {
		c.Logger.Infof("failed to check CRD installation: %s", err.Error())
		return false, err
	}

	return true, nil
}
