// Copyright 2021 The Okteto Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package up

import (
	"context"
	"fmt"
	"time"

	"github.com/okteto/okteto/cmd/utils"
	"github.com/okteto/okteto/pkg/analytics"
	"github.com/okteto/okteto/pkg/config"
	"github.com/okteto/okteto/pkg/errors"
	"github.com/okteto/okteto/pkg/log"
	"github.com/okteto/okteto/pkg/syncthing"
)

func (up *upContext) initializeSyncthing() error {
	sy, err := syncthing.New(up.Dev)
	if err != nil {
		return err
	}
	sy.ResetDatabase = up.resetSyncthing
	up.Sy = sy

	log.Infof("local syncthing initialized: gui -> %d, sync -> %d", up.Sy.LocalGUIPort, up.Sy.LocalPort)
	log.Infof("remote syncthing initialized: gui -> %d, sync -> %d", up.Sy.RemoteGUIPort, up.Sy.RemotePort)

	if err := up.Sy.SaveConfig(up.Dev); err != nil {
		log.Infof("error saving syncthing object: %s", err)
	}

	up.hardTerminate <- up.Sy.HardTerminate()

	return nil
}

func (up *upContext) sync(ctx context.Context) error {
	if err := up.startSyncthing(ctx); err != nil {
		return err
	}

	start := time.Now()
	if err := config.UpdateStateFile(up.Dev, config.Synchronizing); err != nil {
		return err
	}

	if err := up.synchronizeFiles(ctx); err != nil {
		return err
	}

	log.Success("Files synchronized")

	elapsed := time.Since(start)
	analytics.TrackDurationInitialSync(elapsed)
	maxDuration := time.Duration(1) * time.Minute
	if elapsed > maxDuration {
		minutes := elapsed / time.Minute
		elapsed -= minutes * time.Minute
		seconds := elapsed / time.Second
		log.Warning(`File synchronization took %dm %ds
    Consider to update your '.stignore' to optimize the file synchronization
    More information is available here: https://okteto.com/docs/reference/file-synchronization/`, minutes, seconds)
	}

	up.Sy.Type = "sendreceive"
	up.Sy.IgnoreDelete = false
	if err := up.Sy.UpdateConfig(); err != nil {
		return err
	}

	go up.Sy.Monitor(ctx, up.Disconnect)
	go up.Sy.MonitorStatus(ctx, up.Disconnect)
	log.Infof("restarting syncthing to update sync mode to sendreceive")
	return up.Sy.Restart(ctx)
}

func (up *upContext) startSyncthing(ctx context.Context) error {
	spinner := utils.NewSpinner("Starting the file synchronization service...")
	spinner.Start()
	up.spinner = spinner
	defer spinner.Stop()
	if err := config.UpdateStateFile(up.Dev, config.StartingSync); err != nil {
		return err
	}

	if err := up.Sy.Run(ctx); err != nil {
		return err
	}

	if err := up.Sy.WaitForPing(ctx, true); err != nil {
		return err
	}

	if err := up.Sy.WaitForPing(ctx, false); err != nil {
		log.Infof("failed to ping syncthing: %s", err.Error())
		if errors.IsTransient(err) {
			return err
		}
		return up.checkOktetoStartError(ctx, "Failed to connect to the synchronization service")
	}

	spinner.Update("Scanning file system...")
	if err := up.Sy.WaitForScanning(ctx, up.Dev, true); err != nil {
		return err
	}

	if err := up.Sy.WaitForScanning(ctx, up.Dev, false); err != nil {
		return err
	}

	return up.Sy.WaitForConnected(ctx, up.Dev)
}

func (up *upContext) synchronizeFiles(ctx context.Context) error {
	spinner := utils.NewSpinner("Synchronizing your files...")
	up.spinner = spinner
	up.spinner.Start()
	defer up.spinner.Stop()

	progressBar := utils.NewSyncthingProgressBar(40)
	defer progressBar.Finish()

	quit := make(chan bool)

	go func() {
		for {
			select {
			case <-quit:
				return
			case <-time.NewTicker(1 * time.Second).C:
				inSynchronizationFile := up.Sy.GetInSynchronizationFile(ctx)
				if inSynchronizationFile != "" {
					spinner.Stop()
					progressBar.UpdateItemInSync(inSynchronizationFile)
				}
			}
		}
	}()

	reporter := make(chan float64)
	go func() {
		for c := range reporter {
			value := int64(c)
			if value > 0 && value < 100 {
				spinner.Stop()
				progressBar.SetCurrent(value)
			}
		}
		quit <- true
	}()

	if err := up.Sy.WaitForCompletion(ctx, up.Dev, reporter); err != nil {
		analytics.TrackSyncError()
		switch err {
		case errors.ErrLostSyncthing:
			return err
		case errors.ErrInsufficientSpace:
			return up.getInsufficientSpaceError(err)
		case errors.ErrNeedsResetSyncError:
			return errors.UserError{
				E:    fmt.Errorf("the synchronization service state is inconsistent"),
				Hint: `Try running 'okteto up --reset' to reset the synchronization service`,
			}
		default:
			return errors.UserError{
				E: err,
				Hint: `Help us improve okteto by filing an issue in https://github.com/okteto/okteto/issues/new.
    Please include the file generated by 'okteto doctor' if possible.
    Then, try to run 'okteto down -v' + 'okteto up' again`,
			}
		}
	}

	progressBar.SetCurrent(100)

	return nil
}
